alias raw_employee_row = tuple[string, string, string, int, string];
alias employee_row = tuple[string, string, string, int, int];

let employees_table = readCsv(
    ${
        first: string,
        last: string,
        email: string,
        age: int,
        salary: string
    },
    "./tests/resources/csvs/100_line_csv_test",
    true
);

let isDigit = |c: char| -> bool {
    match c {
        case '0' => true,
        case '1' => true,
        case '2' => true,
        case '3' => true,
        case '4' => true,
        case '5' => true,
        case '6' => true,
        case '7' => true,
        case '8' => true,
        case '9' => true,
        case _ => false
    }
};
let salaryToString = |salary: string| -> int {
    salary |> filter(isDigit) |> joinStr("") |> toInt()
};
let formatEmployeeRow = |row: raw_employee_row| -> employee_row {
    (row(0), row(1), row(2), row(3), salaryToString(row(4)))
};
let employees_table_rows: list[employee_row] = employees_table |> collect() |> map(formatEmployeeRow);

let createIncomeFilter = |incomeLimit: int| -> int -> bool {
    |income: int| -> bool {
        income < incomeLimit
    }
};

let incomeFilter = createIncomeFilter(5000);
let requiresPromotion = |employee: employee_row| -> bool {
    incomeFilter(employee(4))
};
let formatSalary = |employee: employee_row| -> raw_employee_row {
    (employee(0), employee(1), employee(2), employee(3), "$" + toStr(employee(4)))
};

let filteredEmployees = employees_table_rows |> filter(requiresPromotion) |> map(formatSalary);
let promotionEmployees = createTable(
    ${
        first: string,
        last: string,
        email: string
        age: int,
        salary: string
    },
    filteredEmployees
);
println(promotionEmployees)
