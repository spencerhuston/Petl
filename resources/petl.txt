TABLE-TYPE:
- columns: schema
- rows: list[tuple(...)]
- funcs w/ table-types:
    - createTable(data: list[tuple(...)], s: schema) -> table
    - writeCsv(path: string, tbl: table, s: schema, header)
    - readCsv(path: string, s: schema, header) -> table
    - join(table1, table2, columns: list[string], where: func[] -> bool) -> table: Inner join two tables
    - with(table, col: name, values: list[any]) -> table:
        Add column "name" with values, type is inferred, if used with existing column it replaces that one
    - select(table, columns: list[string], union[none, func[] -> bool]) -> table:
        Filter rows out with condition into new table
    - columns(table, names: list[string]) -> table: Select multiple columns into new table
    - drop(table, col: string) -> table: Remove column from table
    - column(table, name: string) -> list[any]: Returns column as list of values
    - collect(table) -> list[tuple(...)]: returns list of table rows
    - count(table) -> int: Row count

t1
name,age,salary
Alice,27,$50000
Bob,45,$100000
Mark,23,$35000

t2
name,state
Bob,Idaho
Jack,California
Alice,Texas
Henry,Indiana

left.name
left.age
left.salary
right.name
right.state

intermediate
name,age,salary,state
Alice,27,$50000,Texas
Bob,45,$100000,Idaho
Mark,23,$35000,none
Jack,none,none,California

t1 |> join(t2, ["name", "salary"], "left.name == right.name")

Alice,$50000
Bob,$100000



FEATURES:
1. lambdas only 
2. basic arithmetic 
3. ints, strings, chars, bools, nulls, unions, lists, dicts, tuples, schemas, tables
- type-inference 
- type-aliasing 
- range operator .. 
- string indexing 
4. basic pattern matching 
- match by type: {name}: {type}
- multi-choice: |
- range: ..
- predicates
5. if/else 
6. built-in functions:
General:
    - read stdin
    - read csv
    - output csv
    - output stdout
    - map
    - filter
    - zip
    - foldl
    - foldr
    - slice
    - len
    - type
    - intToString
    - stringToInt
Table:
    - createTable(data: list[tuple(...)], s: schema) -> table
    - writeCSV(path: string, table: table)
    - readCSV(path: string, s: schema) -> table
    - join(table1, table2, func[] -> bool) -> table: Inner join two tables
    - with(table, col: name, values: list[any]) -> table:
        Add column "name" with values, type is inferred, if used with existing column it replaces that one
    - select(table, cols: list[string]) -> table: Select columns
    - drop(table, col: string) -> table: Remove column from table
    - columns(table, names: list[string]) -> list[any]: Returns multiple columns as new table
    - column(table, name: string) -> list[any]: Returns column as list of values
    - collect(table) -> list[tuple(...)]: returns list of table rows
    - count(table) -> int: Row count
7. collection operators
- list append operator: ++
- list/dict/tuple access operator: () (application)
8. REPL 
- args:
     * retl <-d> => run the Retl REPL, optional debug mode
     * retl <-d> <-f> <file_name> => optional debug mode, run file
- steps:
    1. read strings, multi-line denoted by \
    2. scan, parse, type check with environment from REPL
    3. run new code
    4. add to env
10. strong, dynamic typing
11. Iteration over collection objects
12. Comments 

Structure:
ReplRunner
Logger
Scanner
- File Position
Parser
Types
Values
Interpreter

Key characters:
: - denote type
-> - lambda return type
= - assignment, function block start
\ - extend newline
; - end statement
.. - range
+, -, *, /, % = arithmetic ops
>, <, >=, <=, ==, not, and, or - boolean operators
{ - start code block
} - end code block
[ - start list/dict, list/dict access
] - end list/dict, list/dict access
++ - list, dict, tuple concat
( - tuple start
) - tuple end
. - tuple access
, - list, tuple, dict element separator
| - multi-pattern, start of lambda signature, end of lambda signature
_ - catch-all case
=> - case expression
|> - bird operator, chain function calls
$ - schema type denotation (with {})


Keywords:
type
let
int
bool
char
string
null
list
dict
tuple
table
schema
true
false
and
or
if
else
match
case

readln
readCsv
writeCsv
print
println
map
filter
zip
foldl
foldr
foreach
range